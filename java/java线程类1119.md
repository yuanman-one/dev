正课、

一、多线程
 线程依赖于进程
  1、进程
  1.1、进程是操作系统中运行的一个任务（一个应用程序运行在一个进程中）
  1.2、进程是一块包含了某些资源的内存区域，操作系统利用进程把他的工作划分为一些功能单元
  2、多进程的好处
  2.1、可以在一个时间内执行多个任务，提高cpu的使用率
  3、线程
  3.1、进程中所包含的一个或多个执行单元
  3.2、线程是进程的一个顺序执行流 
  4、多线程的好处
  4.1、提高应用程序的使用率
  5、进程和线程的区别
  5.1、一个进程至少有一个线程，线程的划分尺度小于进程，使得多线程程序的并发性高，另外，
               进程在执行过程中拥有独立的内存单元，而多个线程共享，从而极大的提高了程序的运行效率
  5.2、线程在执行过程中与进程的区别在于每个独立的线程有一个程序的入口，顺序执行序列
              和程序的出口，但是线程不能独立运行，必须依存在应用程序中，由应用程序提供多个线程执行控制
  5.3、从逻辑角度看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行，但
              操作系统并没有将多个线程看作多个独立的应用来实现进程的调度和管理以及资源分配    
  6、并发原理
              线程是并发运行的，操作系统将时间划分为很多时间片，尽可能均匀分配给每个线程
              获取时间片，获取时间片的线程cpu运行，而其他线程全部等待，所以微观上是走走停停，
              宏观上都在运行，这种现象叫并发，但是不是绝对意义上的“同时发生”
              注意：多线程不是并行存在的（并行：在一个时间点）              
  7、线程状态
  7.1、新建线程：创建一个线程对象
  7.2、就绪状态：线程对象创建之后，其他线程调用了该对象的strt（）方法，该线程的线程
                位于“可运行线程池”中，变得可运行，只能等待获取cpu的使用权，即在就绪状态的线程除cpu之外，
               其他的运行所需的资源已全部获得
  7.3、运行状态：就绪状态的线程获取了cpu分配的时间片，执行程序代码
  7.4、阻塞状态：线程因为某些原因放弃cpu使用权，暂时停止运行，直到线程进入就绪状态
                  才有机会转到运行状态
  7.5、死亡状态：线程执行完任务或者任务或者遇到error或exception，、
                 退出了run（）方法，该线程结束生命周期           
  8、线程创建方式（Thread）
  8.1、继承Thread并重写run()方法
     注意：1、启动线程要调用start（）方法，而不是直接调用run（）方法
             ：2、当start()方法执行后，线程纳入到线程调度，一旦被分配cpu时间片，线程自动执行run()方法
             ：3.弊端
     a、继承冲突：由于java是单继承，在实际开发中为了可以重复方法，我们通常会继承某个超类，
                     但如果当前类需要特性时，就会导致无法同时继承这两个类
     b、继承线程并重写run()方法来定义线程任务，会导致线程与任务存在一个必须的媾合，这不利于线程的重用      
  8.2、实现Runnable接口，重写run（）方法，单独定义线程任务
  注意：优点
    可以将线程与线程要执行的任务分离减少媾合，同时java是单继承，定义一个类实现Runnable接口
    ，这样做可以更好的去实现其他父类或接口，因为接口是多实现的
    8.3、使用匿名内部类
  9、相关方法
  9.1currentThread() ；获取当前正在运行run（）方法的线程
  9.2、getName() 返回该线程的名称
  9.3、getId() 返回此线程的标识符。
  9.4、getState() 返回此线程的状态。 
  9.5、isAlive() 测试这个线程是否活着。
  9.6、getPriority() 返回此线程的优先级。
     注意：1、线程的优先级分为10级，值为1-10，其中1最低，10最高，线程提供了
     3个常量来表示最低，最高以及默认
     优先级分别是    MAX_PRIORITY 线程可以拥有的最大优先级。 
           MIN_PRIORITY 线程可以拥有的最小优先级。
           NORM_PRIORITY 分配给线程的默认优先级。
      2、线程的切换是由线程调度控制的，我们无法通过代码干涉，但是我们可以提高线程
                   的优先级来最大程度的改善线程获取时间片的几率
  9.7、setPriority(int newPriority) 更改此线程的优先级。    
  9.8、sleep(long millis) 使当前正在执行的线程以指定的毫秒数暂停
                                           （暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。             
                 可以让运行这个方法的线程进入阻塞状态指定毫秒
  9.9、interrupt() 中断这个线程。
            中断线程只不过打断了其阻塞状态，并不是直接把线程中断
  9.10、setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程          
                         当boolean为true，设置此线程为守护线程
                         守护线程又称为后台线程，使用上与普通线程并无区别，但是在结束时机上有一点
                         不同，当一个进程中所有前台线程结束时 ，进程就会结束，这时还在运行的所有
                         守护线程都会被强制终止，设置守护线程要在守护线程运行之前，GC就是一个
                         守护线程
   9.11、join()  等待这个线程死亡。 
                              用于等待当前线程结束，该方法可以协调线程之间的同步运行关系，
                              可以使一个线程在另外一个线程 “后面”等待，直到该线程运行完毕
                              再继续运行
              注意：
              同步运行:执行有先后顺序
              异步运行：各自运行各自的，多线程是异步运行
   10、线程同步
                当多个线程并发操作同一个临界资源时，由于线程切换时机不确定，会导致
                操作资源的代码执行顺序未按照设计要求执行，导致出现操作混乱，严重时可能会导致系统瘫痪
                          
   10.1、判断一个线程是否有安全问题
      1.是否有共享数据
                            共享实例变量
                            共享静态公共变量     
      2.是否是多线程环境
      3.是否有多条语句操作共享数据                  
   10.2、若想解决线程安全问题，需要将异步的操作变为同步操作，其方法如下：    
      1、使用同步块
      a. 有效缩小同步范围可以在保证并发安全的前提下提高并发的效率
      b.语法：synchronized(同步监视对象){
                                  需要同步运行的代码块   
      } 
                  注意：若希望多个线程和那个同步块中的代码，必须保证多个线程看到的同步监视
                      对象是同一个
                      同步监视对象有以下几种：
       a.java中任何对象，结合实际情况自行选择，只要保证多个线程看到是同一个即可
       b.类名.class
       c.使用this作为锁对象
       
       同步的优势
                       解决了多线程的安全问题
       同步的弊端
       当线程相当多的时候，因为每个线程都回去判断同步上的锁，这是很消耗资源的，
       无形中会降低程序的运行效率
                                               
 
                              
   涉及到的知识
     继承
     1、代码复用
     2、语法
       class  类名1（派生类） extends 类名2（超类）{
       }
       
     3、子类/派生类：自己特有的属性和行为
                      父类/超类:所有派生类所共有的属性和行为
     4、
                    若子类继承父类，子类拥有自身的和父类所拥有的属性和行为
     5、单一继承                                
       
      方法重写
      1、发生在父子类之间，方法名称相同，参数列表相同，方法不同
      2、重写遵循“两同两小一大”规则
        2.1两同
                                 方法名相同
                                参数列表相同
        2.2两小
            1.返回值类型       
            void，必须相等
                                  基本数据类型，必须相等
                                  引用数据类型，小于等于超类方法
           2. 派生类方法抛出的异常必须小于等于超类
           2.3一大
                                       派生类方法的访问权限必须大于等于超类方法
       
   接口 
   1、语法
   interface 接口名称{
       public  static  final A=1；//常量  
       public  abstrct 返回值类型 方法名称（参数列表）；//抽象方法
    }
       注意：接口中抽象方法可以省略abstract，会默认提供抽象方法没有方法体
  2、接口中的抽象方法需要在实现类中被重写
    语法：  class 实现类   implements 接口名称{
    }     
   3、如果一个类既继承另外一个类，又实现接口，应先继承类再实现接口
   4、接口可以继承接口    
       
       
       匿名内部类
       1、当想创建一个类（派生类/子类），此类只是为了重写父类的方法，
       此时该类可以不必命名。使用匿名内部类
       语法：
       类名/接口名称   引用变量名称 = new 类名/接口名称（）{
        }
       
       
       
       
       
       
       
       
       
  
  
  
                        